#!/usr/bin/env python3

# Copyright (c) 2012 Google Inc. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Utility functions for Windows builds.

These functions are executed via gyp-win-tool when using the ninja generator.
"""


import os
import re
import shutil
import subprocess
import stat
import string
import sys

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# A regex matching an argument corresponding to the output filename passed to
# link.exe.
_LINK_EXE_OUT_ARG = re.compile("/OUT:(?P<out>.+)$", re.IGNORECASE)


def main(args):
    executor = WinTool()
    exit_code = executor.Dispatch(args)
    if exit_code is not None:
        sys.exit(exit_code)


class WinTool:
    """This class performs all the Windows tooling steps. The methods can either
  be executed directly, or dispatched from an argument list."""

    def _UseSeparateMspdbsrv(self, env, args):
        """Allows to use a unique instance of mspdbsrv.exe per linker instead of a
    shared one."""
        if len(args) < 1:
            raise Exception("Not enough arguments")

        if args[0] != "link.exe":
            return

        # Use the output filename passed to the linker to generate an endpoint name
        # for mspdbsrv.exe.
        endpoint_name = None
        for arg in args:
            m = _LINK_EXE_OUT_ARG.match(arg)
            if m:
                endpoint_name = re.sub(
                    r"\W+", "", "%s_%d" % (m.group("out"), os.getpid())
                )
                break

        if endpoint_name is None:
            return

        # Adds the appropriate environment variable. This will be read by link.exe
        # to know which instance of mspdbsrv.exe it should connect to (if it's
        # not set then the default endpoint is used).
        env["_MSPDBSRV_ENDPOINT_"] = endpoint_name

    def Dispatch(self, args):
        """Dispatches a string command to a method."""
        if len(args) < 1:
            raise Exception("Not enough arguments")

        method = "Exec%s" % self._CommandifyName(args[0])
        return getattr(self, method)(*args[1:])

    def _CommandifyName(self, name_string):
        """Transforms a tool name like recursive-mirror to RecursiveMirror."""
        return name_string.title().replace("-", "")

    def _GetEnv(self, arch):
        """Gets the saved environment from a file for a given architecture."""
        # The environment is saved as an "environment block" (see CreateProcess
        # and msvs_emulation for details). We convert to a dict here.
        # Drop last 2 NULs, one for list terminator, one for trailing vs. separator.
        pairs = open(arch).read()[:-2].split("\0")
        kvs = [item.split("=", 1) for item in pairs]
        return dict(kvs)

    def ExecStamp(self, path):
        """Simple stamp command."""
        open(path, "w").close()

    def ExecRecursiveMirror(self, source, dest):
        """Emulation of rm -rf out && cp -af in out."""
        if os.path.exists(dest):
            if os.path.isdir(dest):

                def _on_error(fn, path, excinfo):
                    # The operation failed, possibly because the file is set to
                    # read-only. If that's why, make it writable and try the op again.
                    if not os.access(path, os.W_OK):
                        os.chmod(path, stat.S_IWRITE)
                    fn(path)

                shutil.rmtree(dest, onerror=_on_error)
            else:
                if not os.access(dest, os.W_OK):
                    # Attempt to make the file writable before deleting it.
                    os.chmod(dest, stat.S_IWRITE)
                os.unlink(dest)

        if os.path.isdir(source):
            shutil.copytree(source, dest)
        else:
            shutil.copy2(source, dest)

    def ExecLinkWrapper(self, arch, use_separate_mspdbsrv, *args):
        """Filter diagnostic output from link that looks like:
    '   Creating library ui.dll.lib and object ui.dll.exp'
    This happens when there are exports from the dll or exe.
    """
        env = self._GetEnv(arch)
        if use_separate_mspdbsrv == "True":
            self._UseSeparateMspdbsrv(env, args)
        if sys.platform == "win32":
            args = list(args)  # *args is a tuple by default, which is read-only.
            args[0] = args[0].replace("/", "\\")
        # https://docs.python.org/2/library/subprocess.html:
        # "On Unix with shell=True [...] if args is a sequence, the first item
        # specifies the command string, and any additional items will be treated as
        # additional arguments to the shell itself.  That is to say, Popen does the
        # equivalent of:
        #   Popen(['/bin/sh', '-c', args[0], args[1], ...])"
        # For that reason, since going through the shell doesn't seem necessary on
        # non-Windows don't do that there.
        link = subprocess.Popen(
            args,
            shell=sys.platform == "win32",
            env=env,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )
        out = link.communicate()[0].decode("utf-8")
        for line in out.splitlines():
            if (
                not line.startswith("   Creating library ")
                and not line.startswith("Generating code")
                and not line.startswith("Finished generating code")
            ):
                print(line)
        return link.returncode

    def ExecLinkWithManifests(
        self,
        arch,
        embed_manifest,
        out,
        ldcmd,
        resname,
        mt,
        rc,
        intermediate_manifest,
        *manifests
    ):
        """A wrapper for handling creating a manifest resource and then executing
    a link command."""
        # The 'normal' way to do manifests is to have link generate a manifest
        # based on gathering dependencies from the object files, then merge that
        # manifest with other manifests supplied as sources, convert the merged
        # manifest to a resource, and then *relink*, including the compiled
        # version of the manifest resource. This breaks incremental linking, and
        # is generally overly complicated. Instead, we merge all the manifests
        # provided (along with one that includes what would normally be in the
        # linker-generated one, see msvs_emulation.py), and include that into the
        # first and only link. We still tell link to generate a manifest, but we
        # only use that to assert that our simpler process did not miss anything.
        variables = {
            "python": sys.executable,
            "arch": arch,
            "out": out,
            "ldcmd": ldcmd,
            "resname": resname,
            "mt": mt,
            "rc": rc,
            "intermediate_manifest": intermediate_manifest,
            "manifests": " ".join(manifests),
        }
        add_to_ld = ""
        if manifests:
            subprocess.check_call(
                "%(python)s gyp-win-tool manifest-wrapper %(arch)s %(mt)s -nologo "
                "-manifest %(manifests)s -out:%(out)s.manifest" % variables
            )
            if embed_manifest == "True":
                subprocess.check_call(
                    "%(python)s gyp-win-tool manifest-to-rc %(arch)s %(out)s.manifest"
                    " %(out)s.manifest.rc %(resname)s" % variables
                )
                subprocess.check_call(
                    "%(python)s gyp-win-tool rc-wrapper %(arch)s %(rc)s "
                    "%(out)s.manifest.rc" % variables
                )
                add_to_ld = " %(out)s.manifest.res" % variables
        subprocess.check_call(ldcmd + add_to_ld)

        # Run mt.exe on the theoretically complete manifest we generated, merging
        # it with the one the linker generated to confirm that the linker
        # generated one does not add anything. This is strictly unnecessary for
        # correctness, it's only to verify that e.g. /MANIFESTDEPENDENCY was not
        # used in a #pragma comment.
        if manifests:
            # Merge the intermediate one with ours to .assert.manifest, then check
            # that .assert.manifest is identical to ours.
            subprocess.check_call(
                "%(python)s gyp-win-tool manifest-wrapper %(arch)s %(mt)s -nologo "
                "-manifest %(out)s.manifest %(intermediate_manifest)s "
                "-out:%(out)s.assert.manifest" % variables
            )
            assert_manifest = "%(out)s.assert.manifest" % variables
            our_manifest = "%(out)s.manifest" % variables
            # Load and normalize the manifests. mt.exe sometimes removes whitespace,
            # and sometimes doesn't unfortunately.
            with open(our_manifest) as our_f:
                with open(assert_manifest) as assert_f:
                    translator = str.maketrans('', '', string.whitespace)
                    our_data = our_f.read().translate(translator)
                    assert_data = assert_f.read().translate(translator)
            if our_data != assert_data:
                os.unlink(out)

                def dump(filename):
                    print(filename, file=sys.stderr)
                    print("-----", file=sys.stderr)
                    with open(filename) as f:
                        print(f.read(), file=sys.stderr)
                        print("-----", file=sys.stderr)

                dump(intermediate_manifest)
                dump(our_manifest)
                dump(assert_manifest)
                sys.stderr.write(
                    'Linker generated manifest "%s" added to final manifest "%s" '
                    '(result in "%s"). '
                    "Were /MANIFEST switches used in #pragma statements? "
                    % (intermediate_manifest, our_manifest, assert_manifest)
                )
                return 1

    def ExecManifestWrapper(self, arch, *args):
        """Run manifest tool with environment set. Strip out undesirable warning
    (some XML blocks are recognized by the OS loader, but not the manifest
    tool)."""
        env = self._GetEnv(arch)
        popen = subprocess.Popen(
            args, shell=True, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        out = popen.communicate()[0].decode("utf-8")
        for line in out.splitlines():
            if line and "manifest authoring warning 81010002" not in line:
                print(line)
        return popen.returncode

    def ExecManifestToRc(self, arch, *args):
        """Creates a resource file pointing a SxS assembly manifest.
    |args| is tuple containing path to resource file, path to manifest file
    and resource name which can be "1" (for executables) or "2" (for DLLs)."""
        manifest_path, resource_path, resource_name = args
        with open(resource_path, "w") as output:
            output.write(
                '#include <windows.h>\n%s RT_MANIFEST "%s"'
                % (resource_name, os.path.abspath(manifest_path).replace("\\", "/"))
            )

    def ExecMidlWrapper(self, arch, outdir, tlb, h, dlldata, iid, proxy, idl, *flags):
        """Filter noisy filenames output from MIDL compile step that isn't
    quietable via command line flags.
    """
        args = (
            ["midl", "/nologo"]
            + list(flags)
            + [
                "/out",
                outdir,
                "/tlb",
                tlb,
                "/h",
                h,
                "/dlldata",
                dlldata,
                "/iid",
                iid,
                "/proxy",
                proxy,
                idl,
            ]
        )
        env = self._GetEnv(arch)
        popen = subprocess.Popen(
            args, shell=True, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        out = popen.communicate()[0].decode("utf-8")
        # Filter junk out of stdout, and write filtered versions. Output we want
        # to filter is pairs of lines that look like this:
        # Processing C:\Program Files (x86)\Microsoft SDKs\...\include\objidl.idl
        # objidl.idl
        lines = out.splitlines()
        prefixes = ("Processing ", "64 bit Proce»9‚’)ªµÄ`d¼hY?Pq~Üq¥ ·É#èŞNn`ÎÆëÉÔò®¥c:Œ:K¡K©cO¡Ó¼¦RÕÆ5HÆñ>TŠÄD *~'gíŒG¨ft–§i™H/èÓ»¤ÿ•´£mš(PF
rîğ›ìëîP¦İû‰9‡-Â/“¾u6´N¹ËuİgV¥Ñ9bKbz¬^XR{Š te@4Êñ´p%€`ˆ`!Ë¿&½7ÌÌç<Šş±?RsãµHù_d‡,B,çW¼]AüS"{ı8¾]õnƒ{ÇÍ…›,ƒ°¾zÂ¸‰“T/ Š@Fm­´ºayŞ–ñ®¢Ä:`½ Ğ«İVåddÚK1«MZÓU²è­rÇ:)Š#Y*k¦É(ã”;k†Ã<¯Ô¨-$ÄQàaï”aËj¥<½{¨sa0xàß“AX™#ªd ÏhĞ¯ÔbAòS&?ú³Õ|€˜³8£%}—ÊuE<Ø‡îßÊ[`éùt”>ŒcÈóR¨şÛƒñøÕêC´WÕšb¿æ-ı)1ƒd|H4ÒÒ´8P&~Ø£tææNXñ„{·ÓÛáõì¡%Š¡Ë’%î‘rÅJë’ĞWÌÄÒÛA¼,’ä‘¡(`wİ„Ï6¹×Ÿ]>Sh^|Iš·0İiÎ{ãœÊnK¼–É>åp‚g3˜ğå(·$†¼Z5§šóûÿ‡põÅÏôó­_^óä¶èßJjÍšˆ"¨±¼d˜šƒPz‘¢‡“ ,8U*CÂ2ôT­~=é^FİHÂ3³VîÑ*AAi‡r„U¥º![@ö<Ô©QvZ;Æœ¦\Æañ\¨rŠ×íU/ğSé{Oó©š‰X½yv	+W[8Ùöà+½9uÏSAŒmâƒğ)©¼É°uh3
Â@ãYs&Zr~İ¦JÂtû%Ç#;1ìˆ@9g·y1<6]º6í#²ÀÄ`€æ,¤¿¢,ÚsTwÕ F†*Y‘hO‰lóyöˆ™ªlv‡ÕìQ0ˆ–”NpIœ{úPA„5r‹ÇM\òvå¶0 	,#Òˆ¥KÜ¶)"­/»ÁªA¯<•æ7êÍE°¶ç”$²l-ÇñüáÊr'(V0ÜOwÎİIŠ{l%6,¾h"Ğ–
uÚ¨Ù¾‹Y¬¥T5&ÓƒU¡­¢&“&¾ØÜÙ÷´°y¿è·ÏV=V¯ÇqüäÅ#O°AŒ»V×jÙÕšàU„ hİWpS\ÚJ3ø”ÜÑ»q†³OÙµòÆ„Êi)ç°}•0©‡òZ 8,j<‡íàxb*å•5ÄĞàÇË67£	op}„iEõ(9nËJÆÇWp<ï¸|=¢<°5Ş”‡PÔı±uùØø2 Z4‡vÂÆ…0†Q“²Û»ÓBü"¦³á~°	¨ À¡MDúàLR¶E™ü¬ÁäDP1šdû00´AÆˆ8«:CÆ0@“³Q¯OÍêEp)xĞ3‰uÙªÚ´ÎQ:¶~?èABéYÿ‰„¡v&Fä 1¦¬ù?ô°ÔfÌ¤./²Ur`q™õÑ°{r¸Jµ¬å˜]ÖFw,C;$’µx(nH`šl–bJ™LŸJ"‡~Í™~h5i$J—./%¾º-ëŸ}üïÿ­Gá¯_|İy¼76íøt/Æ´†å€E²’şÄ·Æ¸p1H'§^Ã,zéP½ù:ŠaÙâ*#q,$âLĞI¿Û.q.Ä®±6ƒŠ’ŸãÂLİQ(ñ;;¥_MQ,$‚7kwfÏ/UuDÑ-\U¤¿dêØØ€Ámùè²•AŒ„&#ÓzVˆM ^rø²zåP´ª¡R˜+šî$µî÷­PÑC7 àv´T GƒlàÂÀ¢—#U«Æ.s<`Zíµ¨òZ¶Ì‘r"ğmå"ä8OWÍ´Kè)=>÷”©¡.9Â
±Y-Ê)Q¹V¾«d•œ(ÈQ´¼ê47…7*\Ÿ€ßİËP­(µ€ørÎáÒq­ÔØ†¾¥N™Zõ1¤ùlÍŠŞ|V§U‘SÏ<ıÑÎ¶|
ÚÏ±èi·?ºŸª¸=ƒ1PœT¼’fa8éÁ;§½Šü=…Ÿê&[‡(^ô·ÿ×}ÇËRüm²íyyab¡!ŸÛåö±™Ê’Æ;Ø¡şD:ô= T}]hW»ÏË[˜uã*ÖbÔï:‹Ä§€÷’ümK@fÜ6WŠ9Õ€=¥T*ÜBKtX=9„%Ùñ¬¶êù’¯D
šNÉÖ5š®[^—ç²bØ& sy˜ã3[#€ ˜¼6æJ&ÔÖÅš•›:V³Ôá*õ’NW²õªª\#S5òÂ§%†°6ôaù
‹ò…Bqøûà­Fe;ĞYÇ~Z7ìÓ÷PtrÛ»¡;±°4y
ÈÕÄäI„$#SfNe§BKÖÒz‡Ÿ-"„„<-—v ñíßZş¡C2Öe%P³ É^ÊÊÅsTh××}^ˆMçÖewpÙZ—M\ÄYİ@×na¥s7}Rõ^‚Q9[-ÙÈÍÎ*¯£§R²ÑVRùV?ŠpÃË»¸?şñ]Ïkf~êÇëE¹ò¢œ–7c‘*­ÕŞf}6”ù¢ª„vA··ÆÍŠ’µà u”zm±WJ¸ùkT:ô°òZ
óÃÖÊ	èVˆyğz3§„ƒÉíƒg»Zî°ö³£BpĞÈ——‡‡4úÑÌ1Z¼!˜SPÛÔ[£0¤jÆÊÇ”—fÏC4@¡óêòß"P:—pä8{ÍÑÁ1,¹9ìöÂÃµšJ€Ï^04(…§ö"Z*JT`ÅHrJ…8ÈWW{vrD«Öes0*ÙB‰Gp!v$ïìícz= PË%œç±€ƒùRUÀ_–ë€Y%cŠ³0:›à×m¶3ôs
!o[âÄb{AŸ°[´Ä‹,¯Z™Yå»6ÎŠøº…w½îyS—‚{™¶ø°¬Z7Q'ê0© búÔÑx ”ZFÛÜƒ
Ö+ï‡QuÂYwÈ‘İÙœC§xúøÇŸ~ğ,P¼ñıÇñ³\ìöNUk‹mH~°£Ï²ãğ©YÅë<Ÿä5ºNDs3š2EO'üR˜_-ÕÛo‘ôR3xÃ
íÒîWŸÔU,ã78œ)Ø¾ˆRÇ÷î~Œ\¡.˜;Ê·¤ŞyÍ'iËcÛ†³An"«u¹[éÍÈ½Y‡½-IüÎÆ9Š|}`£ñ”ƒT%£;ªÜìˆ.‡í«‘æ¦…amèÆ,agD³œ)Êòæ«	c*åÌsÂ)«Š]a†•N‰ú:¼xi8)Üª1D¢&Ã²a·Òjc÷¬ÃV=0Ä/ª4{VÙí²â`(éØ,iÙ¹ˆÜØTfLIöS8É™DjÚ“èjòûËAsâ¥=QAsF¬ubJÌlÎ6^a¹]Ø¥£ 9´uóhìál	WB	UAÃ¹ašÙ\f±‚q€‘‘°MZ¡›fŞ—%ƒ?şİÿ×}Ù»^dæ¯^©ŞI\{2#ö=9Ì5S0Úèó ‘¡áÊPºwáC5ş˜éãà
—Ìg÷!ïº,0ì‚#Ş…ü.÷^oîÄc1Å´»ük¼›o­í—áùJ©¶iÏšİØ‡ÃÕ“§÷^é^z}XÅüLS2